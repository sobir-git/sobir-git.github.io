<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>My Notes - data structures &amp; algorithms</title><link href="/" rel="alternate"></link><link href="/feeds/data-structures-algorithms.atom.xml" rel="self"></link><id>/</id><updated>2021-05-10T00:00:00+03:00</updated><entry><title>Selection algorithm</title><link href="/selection-algorithm.html" rel="alternate"></link><published>2021-05-10T00:00:00+03:00</published><updated>2021-05-10T00:00:00+03:00</updated><author><name>Sobir Bobiev</name></author><id>tag:None,2021-05-10:/selection-algorithm.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Selection algorithm is an algorithm for finding k-th smallest element in an array.&lt;/strong&gt; An inefficient implementation is to sort the array and return the k-th element, which has &lt;span class="math"&gt;\(O(n \log n)\)&lt;/span&gt; time complexity. However, there exists selection algorithms with O(n) worst-case complexity. &lt;/p&gt;
&lt;h2&gt;Quickselect&lt;/h2&gt;
&lt;p&gt;The best known selection algorithm …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Selection algorithm is an algorithm for finding k-th smallest element in an array.&lt;/strong&gt; An inefficient implementation is to sort the array and return the k-th element, which has &lt;span class="math"&gt;\(O(n \log n)\)&lt;/span&gt; time complexity. However, there exists selection algorithms with O(n) worst-case complexity. &lt;/p&gt;
&lt;h2&gt;Quickselect&lt;/h2&gt;
&lt;p&gt;The best known selection algorithm is known as &lt;strong&gt;Quickselect&lt;/strong&gt;. It works like quicksort, using divide and conquer method. Its complexity is on average linear but worst case is quadratic, which depends on the pivot selecting strategy. Good pivots are those that divide the array into approximately equal parts, such as median, however this they can not be efficiently computed. &lt;/p&gt;
&lt;h2&gt;Median of medians&lt;/h2&gt;
&lt;p&gt;One famous algorithm for finding &lt;em&gt;aproximate median&lt;/em&gt; is called &lt;strong&gt;median of medians&lt;/strong&gt;. It partitions the array into parts having at most 5 elements, and computes the median of each partition. It then recurses with &lt;span class="math"&gt;\(n/5\)&lt;/span&gt; medians. It has &lt;strong&gt;linear time complexity&lt;/strong&gt; as such: 
&lt;/p&gt;
&lt;div class="math"&gt;$$
n + n/5 + n/5^2 + \ldots = cn
$$&lt;/div&gt;
&lt;p&gt;
for some constant &lt;span class="math"&gt;\(c\)&lt;/span&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="data structures &amp; algorithms"></category></entry><entry><title>Sorting</title><link href="/sorting.html" rel="alternate"></link><published>2021-05-10T00:00:00+03:00</published><updated>2021-05-10T00:00:00+03:00</updated><author><name>Sobir Bobiev</name></author><id>tag:None,2021-05-10:/sorting.html</id><summary type="html">&lt;h2&gt;Quicksort 0&lt;/h2&gt;
&lt;p&gt;As an inspiration, this is a very beatiful implementation of quicksort. However not so efficient.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;partition&lt;/code&gt; procedure maintains a pointer &lt;code&gt;i&lt;/code&gt; for which all elements &lt;code&gt;A[0 .. i - 1] &amp;lt; pivot&lt;/code&gt;.
At the end, it correctly places &lt;code&gt;pivot&lt;/code&gt; in position &lt;code&gt;A[i]&lt;/code&gt; by swapping.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;algorithm quicksort(A, lo, hi …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;Quicksort 0&lt;/h2&gt;
&lt;p&gt;As an inspiration, this is a very beatiful implementation of quicksort. However not so efficient.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;partition&lt;/code&gt; procedure maintains a pointer &lt;code&gt;i&lt;/code&gt; for which all elements &lt;code&gt;A[0 .. i - 1] &amp;lt; pivot&lt;/code&gt;.
At the end, it correctly places &lt;code&gt;pivot&lt;/code&gt; in position &lt;code&gt;A[i]&lt;/code&gt; by swapping.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;algorithm quicksort(A, lo, hi) is
    if lo &amp;lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p - 1)
        quicksort(A, p + 1, hi)

algorithm partition(A, lo, hi) is
    pivot := A[hi]
    i := lo
    for j := lo to hi do
        if A[j] &amp;lt; pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[hi]
    return i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Quicksort 1&lt;/h2&gt;
&lt;p&gt;This is the original implementation by Hoare&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;algorithm quicksort(A, lo, hi) is
    if lo &amp;lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p)
        quicksort(A, p + 1, hi)

algorithm partition(A, lo, hi) is
    pivot := A[ floor((hi + lo) / 2) ]
    i := lo - 1
    j := hi + 1
    loop forever
        do
            i := i + 1
        while A[i] &amp;lt; pivot
        do
            j := j - 1
        while A[j] &amp;gt; pivot
        if i ≥ j then
            return j
        swap A[i] with A[j]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;compared to previous implementation this does less swap operations.&lt;/p&gt;
&lt;h2&gt;Partition schemes&lt;/h2&gt;
&lt;p&gt;As you have noticed different implementations differ by their partition schemes, that is how they partition the array into two subarrays where all elements in the first subarray are no greater than the elements in the second subarray. The algorithm proceeds recursively to sort each of the subarrays. What stands between the subarrays is &lt;em&gt;pivot&lt;/em&gt;. Some implementations choose pivot as the first or last or middle or median element of the array. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Choices of pivot:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The best pivot is &lt;strong&gt;median&lt;/strong&gt;, but it's often inefficient to compute.&lt;/li&gt;
&lt;li&gt;Pivot as &lt;strong&gt;first or last element&lt;/strong&gt; produces worst case &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt; runtime when the array is already sorted. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Random pivots&lt;/strong&gt; are a good choice.&lt;/li&gt;
&lt;li&gt;Pivot as the &lt;strong&gt;median of the first, middle and last element&lt;/strong&gt; not only eliminates worst case runtime for already sorted arrays but turns them into best cases.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Questions to consider:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What happens when all elements are equal?&lt;/li&gt;
&lt;li&gt;What happens when multiple elements are equal to the pivot?&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="data structures &amp; algorithms"></category></entry><entry><title>Bloom filter</title><link href="/bloom-filter.html" rel="alternate"></link><published>2021-05-09T00:00:00+03:00</published><updated>2021-05-09T00:00:00+03:00</updated><author><name>Sobir Bobiev</name></author><id>tag:None,2021-05-09:/bloom-filter.html</id><summary type="html">&lt;h2&gt;Idea&lt;/h2&gt;
&lt;p&gt;How sets are implemented? They are usually implemented using hash tables with dummy values. An important function of a set is know whether an element is present or not. From computational perspective this includes comparison operation between the query element and the value stored. However, when the number of …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Idea&lt;/h2&gt;
&lt;p&gt;How sets are implemented? They are usually implemented using hash tables with dummy values. An important function of a set is know whether an element is present or not. From computational perspective this includes comparison operation between the query element and the value stored. However, when the number of elements is too large, it may not be stored in memory, but only in disk which is costly to read. It is very beneficial if we could early on tell if an does not exist in the set, and avoid disk access. This is the idea of Bloom filters: sometimes they can tell you exactly when an element does not exist. This is a probabilistic data structure.&lt;/p&gt;
&lt;h2&gt;Algorithm&lt;/h2&gt;
&lt;h3&gt;Start simple, &lt;span class="math"&gt;\(k = 1\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Let's start with a basic idea. What if we use a hash function maps the set element to integer indices in range &lt;span class="math"&gt;\(1..m\)&lt;/span&gt;? Then, we could maintain a bit-array of size &lt;span class="math"&gt;\(m\)&lt;/span&gt; so that for each element in the set the corresponding position in the bit-array is marked as 1. Collisions can happen: two or more elements can be mapped to the same position by the hash function. However, for values that are not elements of the set, their hashes may correspond to 0-valued positions in the bit-array, thus, letting us know early on that they don't belong to set. In other words, we would have no false negatives. False positives are still possible, when the hash of a non-element value collides with some elements in the set. In this case we have to go the usual way of set operations are done. &lt;/p&gt;
&lt;h3&gt;Going further, &lt;span class="math"&gt;\(k &amp;gt; 1\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;The idea is still valid, and more powerful if we let &lt;span class="math"&gt;\(k &amp;gt; 1\)&lt;/span&gt;. In other words we use &lt;span class="math"&gt;\(k\)&lt;/span&gt; different hash functions. On one side, they increase saturation of bit-array. On the other hand, for a non-element value they can increase the probability that one of the hash values maps to 0-valued position in the bit-array, which tells us that the element does not exist in the set. &lt;/p&gt;
&lt;p&gt;&lt;img alt="bloom filter" src="https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg"&gt;&lt;/p&gt;
&lt;h3&gt;Some math and optimal &lt;span class="math"&gt;\(k\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href="https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives"&gt;wikipedia article&lt;/a&gt; presents the &lt;strong&gt;probability of false positives&lt;/strong&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$
\epsilon =\left(1-\left[1-{\frac {1}{m}}\right]^{kn}\right)^{k}
\approx \left(1-e^{-kn/m}\right)^{k}
$$&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(n\)&lt;/span&gt; is the number of elements in the set.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;optimal number of hash functions&lt;/strong&gt;, &lt;span class="math"&gt;\(k\)&lt;/span&gt;, for fixed values of &lt;span class="math"&gt;\(n\)&lt;/span&gt; and &lt;span class="math"&gt;\(m\)&lt;/span&gt; is given as
&lt;/p&gt;
&lt;div class="math"&gt;$$
k = \frac{m}{n}\ln 2
$$&lt;/div&gt;
&lt;h2&gt;Pros and cons:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Space efficient. The memory it takes is constant irrespective of the number of elements in the set. However false positive rate increases with the number of elements.&lt;/li&gt;
&lt;li&gt;It does not support removing of elements.&lt;/li&gt;
&lt;li&gt;The union operation is fast, consists of bitwise OR operation. Also it is looseless, meaning that the filter produced will be as if it were created from scratch using all elements.&lt;/li&gt;
&lt;li&gt;The intersection operation is also fast, and is done with bitwise AND operation. However, it is loosy, the produced filter has higher false positive rate than if were created from scratch.&lt;/li&gt;
&lt;li&gt;Fast approximation formulas of the size of intersection or union of two sets.&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="data structures &amp; algorithms"></category></entry><entry><title>Hash tables</title><link href="/hash-tables.html" rel="alternate"></link><published>2021-05-09T00:00:00+03:00</published><updated>2021-05-09T00:00:00+03:00</updated><author><name>Sobir Bobiev</name></author><id>tag:None,2021-05-09:/hash-tables.html</id><summary type="html">&lt;p&gt;Hash tables are there to implement &lt;strong&gt;dictionary (map) data structure&lt;/strong&gt;, mapping keys to values.&lt;/p&gt;
&lt;p&gt;For computers the more native structure is array. Locating elements are easy because they have integer indices that can be mapped to precise memory locations.&lt;/p&gt;
&lt;p&gt;But in order to create artibrary mapping with any type of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hash tables are there to implement &lt;strong&gt;dictionary (map) data structure&lt;/strong&gt;, mapping keys to values.&lt;/p&gt;
&lt;p&gt;For computers the more native structure is array. Locating elements are easy because they have integer indices that can be mapped to precise memory locations.&lt;/p&gt;
&lt;p&gt;But in order to create artibrary mapping with any type of key one must decide how those keys should be mapped to integer values. One has to decide the maximum size of index. A hash function is a function that maps key to integer index:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;index = f(key, array_size)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Hash functions generally output very large numbers, and their output is reduced to something no more that array_size by module operation.&lt;/p&gt;
&lt;p&gt;Good hash functions are those that produce uniform outputs. The less uniform their outputs are, the more collisions occur.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Load factor&lt;/strong&gt; is very important metric: &lt;span class="math"&gt;\(n / k\)&lt;/span&gt;, where &lt;span class="math"&gt;\(n\)&lt;/span&gt; is the number of occupied entries and &lt;span class="math"&gt;\(k\)&lt;/span&gt; is the bucket size. The larger the bucket size, the less collisions there be, but the more space is required. Another important statistic is variance of number of entries per bucket. Of cource less variance is better, and an optimal case is where all buckets contains at most one entry. As the load factor increases, the hash tables becomes slow. &lt;/p&gt;
&lt;p&gt;So, how &lt;strong&gt;collisions are resolved&lt;/strong&gt;? Two or more keys can be mapped to the same bucket. Therefore it is inevitable to store multiple key, value pairs in each bucket. Often a simple data structure like &lt;strong&gt;linked list&lt;/strong&gt; is used to solve this. However, there are tons of other methods that are good in particular situations depending on the number of entries and buckets, and in terms of space or performance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Can the number of buckets be increased?&lt;/strong&gt; It's called &lt;strong&gt;dynamic resizing&lt;/strong&gt;. Yes it can be increased but it requires to move existing entries around, &lt;em&gt;rehashing&lt;/em&gt;. Resizing is sometimes triggered automatically when the load factor exceed some threshold. Shrinking is also possible for the purpose of reducing wasted space by empty buckets. &lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="data structures &amp; algorithms"></category></entry><entry><title>K-d trees</title><link href="/k-d-trees.html" rel="alternate"></link><published>2021-05-09T00:00:00+03:00</published><updated>2021-05-09T00:00:00+03:00</updated><author><name>Sobir Bobiev</name></author><id>tag:None,2021-05-09:/k-d-trees.html</id><summary type="html">&lt;p&gt;Suppose we have a set of vectors. We need a data structure for querying nearest neighbor and range searches. kd-tree is a tree where at each level the points are split by a hyperplance according to a coordinate.&lt;/p&gt;
&lt;h2&gt;Construction&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;kdtree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;Suppose we have a set of vectors. We need a data structure for querying nearest neighbor and range searches. kd-tree is a tree where at each level the points are split by a hyperplance according to a coordinate.&lt;/p&gt;
&lt;h2&gt;Construction&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;kdtree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

    &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c1"&gt;# assumes all points have the same dimension&lt;/span&gt;
    &lt;span class="c1"&gt;# Select axis based on depth so that axis cycles through all valid values&lt;/span&gt;
    &lt;span class="n"&gt;axis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;

    &lt;span class="c1"&gt;# Sort point list by axis and choose median as pivot element&lt;/span&gt;
    &lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;# can be found in O(n), see &amp;quot;Selection algorithms&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;median&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

    &lt;span class="c1"&gt;# Create node and construct subtrees&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;median&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="n"&gt;left_child&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;kdtree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;median&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;right_child&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;kdtree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;median&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;:],&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Complexity: &lt;span class="math"&gt;\(O(n \log n)\)&lt;/span&gt; if median is found using an algorithm of &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; complexity.&lt;/p&gt;
&lt;h2&gt;Adding elements&lt;/h2&gt;
&lt;p&gt;To add an element, traverse the tree until you reach a leaf node. Add the point either as the left or right child node, according to how the space must be split.&lt;/p&gt;
&lt;p&gt;Complexity: &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Removing elements&lt;/h2&gt;
&lt;p&gt;To remove a point first we locate the node containing the target point. An obvious way to remove the point is to retrieve all points in subtrees of the node and recreate that part of the tree. However this can be costly if the point to be removed is located high in the tree.&lt;/p&gt;
&lt;p&gt;Another way is to replace the target point with another point, say p, in the tree. Then recursively remove the point p from the tree. How to find the suitable replacement point that does not invalidate the properties of the tree? The answer is to look at the right subtree and get the point with the maximum coordinate. If right subtree is empty, do similar with the left subtree, find a point with the minimum coordinate.&lt;/p&gt;
&lt;p&gt;Complexity: &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Nearest neighbor search&lt;/h2&gt;
&lt;p&gt;To find the nearest neighbor to a given input point we traverse the tree once. As we visit nodes, we keep record of the &lt;em&gt;current best&lt;/em&gt;, that is nearest point found so far. At each node we proceed by choosing the subspace that the input point fall into. However, the nearest neighbor could be located on the other subspace. To solve this we consider a hypersphere around the input point with radius equal to the distance to the current nearest point. If the hypersphere crosses the hyperplane we recursively search both subspaces. Otherwise we only search the current subspace.&lt;/p&gt;
&lt;p&gt;Complexity: &lt;span class="math"&gt;\(O(n \log n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Range search&lt;/h2&gt;
&lt;p&gt;&lt;img alt="range search with kd-tree" src="/images/kd-tree-range-search.png"&gt;&lt;/p&gt;
&lt;p&gt;Complexity: &lt;span class="math"&gt;\(O(n^{1 - 1/k} + a)\)&lt;/span&gt; where &lt;span class="math"&gt;\(a\)&lt;/span&gt; is the result size.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="data structures &amp; algorithms"></category></entry><entry><title>Binary Search once and for all</title><link href="/binary-search-once-and-for-all.html" rel="alternate"></link><published>2021-05-06T00:00:00+03:00</published><updated>2021-05-06T00:00:00+03:00</updated><author><name>Sobir Bobiev</name></author><id>tag:None,2021-05-06:/binary-search-once-and-for-all.html</id><summary type="html">&lt;p&gt;&lt;em&gt;This is inspired by the following &lt;a href="https://youtu.be/tgVSkMA8joQ"&gt;youtube tutorial&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Binary search is so intuitive but very tricky to code. I consider two main difficulties:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tricky to ensure termination, many times it falls into an infinite loop.&lt;/li&gt;
&lt;li&gt;Knowing exactly &lt;em&gt;what&lt;/em&gt; to search.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first issue is arithmetical, you have to make sure …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;This is inspired by the following &lt;a href="https://youtu.be/tgVSkMA8joQ"&gt;youtube tutorial&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Binary search is so intuitive but very tricky to code. I consider two main difficulties:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tricky to ensure termination, many times it falls into an infinite loop.&lt;/li&gt;
&lt;li&gt;Knowing exactly &lt;em&gt;what&lt;/em&gt; to search.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first issue is arithmetical, you have to make sure each time the search interval is &lt;strong&gt;strictly shortening&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The second issue has to do with the way you formulate your &lt;em&gt;search objective&lt;/em&gt;. However, all binary search problems can be converted to the following problem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Consider a binary array with the following property: no &lt;code&gt;true&lt;/code&gt; comes before any &lt;code&gt;false&lt;/code&gt;: e.g. FFFFFFTTTT, FFFFF, TTT&lt;/p&gt;
&lt;p&gt;Then, the binary search problem is to find the leftmost insertion location for another &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We end with the following python psuedocode:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bisect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;Find the leftmost insertion location of &lt;/span&gt;
&lt;span class="sd"&gt;    another True in the sorted binary array.&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

    &lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;# arr[mid] is False&lt;/span&gt;
            &lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;bisect&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;bisect&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;bisect&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="data structures &amp; algorithms"></category></entry></feed>